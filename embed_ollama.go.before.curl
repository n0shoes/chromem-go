package chromem

//	"errors"
import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"sync"
	"time"
)

const defaultBaseURLOllama = "http://localhost:11434/api"

type ollamaResponse struct {
	Embeddings [][]float32 `json:"embeddings"`
}

// NewEmbeddingFuncOllama returns a function that creates embeddings for a text
// using Ollama's embedding API. You can pass any model that Ollama supports and
// that supports embeddings. A good one as of 2024-03-02 is "nomic-embed-text".
// See https://ollama.com/library/nomic-embed-text
// baseURLOllama is the base URL of the Ollama API. If it's empty,
// "http://localhost:11434/api" is used.
func NewEmbeddingFuncOllama(model string, baseURLOllama string) EmbeddingFunc {
	if baseURLOllama == "" {
		baseURLOllama = defaultBaseURLOllama
	}

	// We don't set a default timeout here, although it's usually a good idea.
	// In our case though, the library user can set the timeout on the context,
	// and it might have to be a long timeout, depending on the text length.
	// Disable connection reuse to avoid EOF errors with Ollama's internal services
	client := &http.Client{
		Transport: &http.Transport{
			DisableKeepAlives: true, // Force new connection each time
		},
	}

	var checkedNormalized bool
	checkNormalized := sync.Once{}

	return func(ctx context.Context, text string) ([]float32, error) {
		// Prepare the request body.
		reqBody, err := json.Marshal(map[string]string{
			"model": model,
			"input": text,
		})

		if err != nil {
			return nil, fmt.Errorf("couldn't marshal request body: %w", err)
		}

		url := baseURLOllama + "/embed"
		fmt.Printf("[DEBUG] Ollama embedding request - URL: %s, text length: %d bytes\n", url, len(text))

		// Create the request. Creating it with context is important for a timeout
		// to be possible, because the client is configured without a timeout.
		req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(reqBody))
		if err != nil {
			return nil, fmt.Errorf("couldn't create request: %w", err)
		}
		req.Header.Set("Content-Type", "application/json")

		// Send the request.
		resp, err := client.Do(req)
		if err != nil {
			return nil, fmt.Errorf("couldn't send request: %w", err)
		}
		defer resp.Body.Close()

		//Check the response status.
		//if resp.StatusCode != http.StatusOK {
		//	return nil, errors.New("Error response from the embedding API: " + resp.Status)
		//}
		//fmt.Println("Status is :", resp.Status)
		//fmt.Println("Headers are :", resp.Header)


		bodyBytes, err := io.ReadAll(resp.Body)
		fmt.Printf("[DEBUG] Ollama response - Status: %d, body length: %d bytes\n", resp.StatusCode, len(bodyBytes))
		if err != nil {
		       //panic(err)
		       return nil, fmt.Errorf("couldn't read response body: %w", err)
		}

		if resp.StatusCode != http.StatusOK {
  		   return nil, fmt.Errorf("error response from Ollama API: %s (status %d), body: %s",
  		   	       		resp.Status, resp.StatusCode, string(bodyBytes))
  		}


		// Convert to string and print
		// fmt.Println("Body:", string(bodyBytes))
		// Read and decode the response body.
		// body, err := io.ReadAll(resp.Body)
		// if err != nil {
		// 	return nil, fmt.Errorf("couldn't read response body: %w", err)
		// }

		var embeddingResponse ollamaResponse
		var sb = string(bodyBytes)
		sb = strings.TrimSpace(sb)
		bytes := []byte(sb)
		err = json.Unmarshal(bytes, &embeddingResponse)
		if err != nil {
			return nil, fmt.Errorf("couldn't unmarshal response body: %w, %s", err, bodyBytes)
		}

		// Check if the response contains embeddings.
		// if len(embeddingResponse.Embeddings) == 0 {
		//	return nil, errors.New("no embeddings found in the response")
		//}

		if len(embeddingResponse.Embeddings) == 0 || len(embeddingResponse.Embeddings[0]) == 0 {
  		   return nil, fmt.Errorf("no embeddings found in response, body: %s", string(bodyBytes))
  		}

		// Add delay to prevent overwhelming Ollama's internal services
  		time.Sleep(500 * time.Millisecond)


		v := embeddingResponse.Embeddings[0]
		checkNormalized.Do(func() {
			if isNormalized(v) {
				checkedNormalized = true
			} else {
				checkedNormalized = false
			}
		})
		if !checkedNormalized {
			v = normalizeVector(v)
		}

		return v, nil
	}
}
